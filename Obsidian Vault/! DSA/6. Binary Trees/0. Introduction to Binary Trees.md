- hierarchical data structure

- a tree where a node can have a max of 2 children
- anything that stores data is a node
- leaf nodes have zero children
- ancestor
	  anything on top of that path of a node?
- any portion of tree extracted out is called subtree

- **Full Binary Tree** 
	  all nodes must have 2 or 0 children

- **Complete Binary Tree**
	  all levels completely filled except the last
	  last level has all nodes as left as possible

- **Perfect Binary Tree**
	  all leaf nodes are at the same level
	  all non-leaf nodes must have 2 nodes

- **Balanced Binary Tree**
	  height difference between left and right subtree at any node must be at max 1

- **Degenerate Binary Tree** 
	  every node has a single child

## Representation 
### C++
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int data1) : data(data1), left(nullptr), right(nullptr) {}
    Node(int data1, Node* left1) : data(data1), left(left1), right(nullptr) {}
    Node(int data1, Node* left1, Node* right1) : data(data1), left(left1), right(right1) {}
};

/*
struct Node{
	int data;
	Node* left
	Node* right;

	Node(int data1){
		data = data1;
		left = right = nullptr;
	}
	Node(int data1, Node* left1){
		data = data1;
		left = left1;
		right = nullptr;
	}
	Node(int data1, Node* right1){
		data = data1;
		left = nullptr;
		right = right1;
	}
	Node(int data1, Node* left1, Node* right1){
		data = data1;
		left = left1;
		right = right1;
	}
};
*/

int main(){
	Node* root = new Node(1);
	root->left = new Node(2);
	root->right = new Node(3);
	root->left->left = new Node(4);
	
//        (1)
//		 /   \
//	  (2)     (3)
//	  /
// (4)
  
}
```
### Java
```java
class Node {
    int data;
    Node left;
    Node right;

    // Constructor with only data
    Node(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }

    // Constructor with data and left child
    Node(int data, Node left) {
        this.data = data;
        this.left = left;
        this.right = null;
    }

    // Constructor with data and right child
    Node(int data, Node right, boolean isRightOnly) {
        this.data = data;
        this.left = null;
        this.right = right;
    }

    // Constructor with data, left and right children
    Node(int data, Node left, Node right) {
        this.data = data;
        this.left = left;
        this.right = right;
    }
}
//⚠️ Java doesn’t allow two constructors with the same parameter types, so to distinguish between a `(int, Node)` for left or right only, we add a dummy boolean `isRightOnly` in one version.

public class BinaryTreeDemo {
    public static void main(String[] args) {
        // Creating nodes
        Node leftChild = new Node(2);
        Node rightChild = new Node(3);

        // Root node with both children
        Node root = new Node(1, leftChild, rightChild);

        // Print tree root and children
        System.out.println("Root: " + root.data);
        System.out.println("Left Child: " + root.left.data);
        System.out.println("Right Child: " + root.right.data);
    }
}

```