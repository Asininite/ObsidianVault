

 \- Analysis (front-end)
	1. lexical analyzer
		   read source code character by character and group into lexemes. For each lexeme, generate token
		   raw source code -> stream of tokens
	2. syntax analyzer (parsing)
		   check if stream of tokens forms valid structure and make parse tree
		   stream of tokens -> abstract parse tree
	3. semantic analysis
		   check semantic structure of parse tree
			   type checking 
			   declaration checking
			   scope resolution
		   abstract parse/syntax tree -> annotated parse/syntax tree
- Synthesis (back-end)
	1. Intermediate Code Generation (ICG)
		    translate semantically verified AST to machine-independent intermediate representation
		    annotated AST -> intermediate code
	2. Code Optimization
		   improve intermediate code to make code run faster/use less memory
	3. Target code generation
		   translate intermediate code into target code
		   optimized intermediate code -> target code

- symbol table interacts with all the phases of compiler 
- error handler also interacts with all the phases

![[Pasted image 20250216194841.png]]

![[Pasted image 20250216235308.png]]
### 1. Lexical Analysis
- takes source program and converts to **lexeme**(sequence of characters)
- takes lexemes as input and generates tokens of the form '<token-name, attribute-value>' 
- ![[Pasted image 20250216235308.png]]
	![[Pasted image 20250216234920.png]]
- ![[Pasted image 20250216184628.png]]
### 2. Syntax Analysis
- uses the first components of the tokens produced by lexical analyzer to create a tree intermediate representation that depicts the grammar of the token stream
- syntax tree where each node is operation and children are the arguments of the operations
- ![[Pasted image 20250216235250.png]]

### 3. Semantic Analysis
- uses syntax tree and info in symbol table to check the semantic consistency with language definition
	type checking : ensures operations performed on compatible data types i.e, no int + string
	variable declaration : 
	function calls :
	consistency with language rules :
- ![[Pasted image 20250217002705.png]]

### 4. Intermediate Code Generation
- compilers generate machine-like intermediate code
- simple and easy to produce
	easy to translate into target machine
- ![[Pasted image 20250217003050.png]]

### 5. Code Optimization
- ![[Pasted image 20250217003125.png]]
- attempts to improve the intermediate code to get a better target code

- ![[Pasted image 20250217104212.png]]
- 