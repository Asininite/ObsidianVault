1. **Interrupt Request:** An interrupt request is signaled to the CPU.
    
    - **Hardware Interrupts:** These arrive on either the NMI (Non-Maskable Interrupt) pin or the INTR (Interrupt Request) pin. NMI interrupts are always serviced, while INTR interrupts can be masked by the IF (Interrupt Flag) in the flags register.
        
    - **Software Interrupts:** These are generated by executing an INT n instruction, where n is the interrupt type.
        
2. **Current Instruction Completion:** The CPU completes the execution of the current instruction before responding to the interrupt. This ensures predictable behavior.
    
3. **Interrupt Acknowledge (for INTR only):** If the interrupt is a hardware interrupt on the INTR pin and the IF flag is set, the CPU performs two interrupt acknowledge cycles (INTA):
    
    - **INTA Cycle 1:** The CPU sends a pulse on the INTA pin.
        
    - **INTA Cycle 2:** The CPU sends another pulse on the INTA pin. During this cycle, the interrupting device places the interrupt type (a number from 0-255) onto the data bus.
        
4. **Flags and Return Address Push:** The CPU pushes the following registers onto the stack in this order:
    
    - **Flags Register:** The current state of the flags is saved.
        
    - **CS (Code Segment) Register:** The segment address of the next instruction in the interrupted program is saved.
        
    - **IP (Instruction Pointer) Register:** The offset address of the next instruction in the interrupted program is saved. Together, CS:IP form the return address.
        
5. **Interrupt Flag and Trap Flag Clear (for hardware interrupts):**
    
    - **IF = 0:** The Interrupt Flag is cleared to prevent further INTR interrupts from being recognized until the current interrupt is handled. NMI interrupts are not affected by the IF flag.
        
    - **TF = 0 (if applicable):** If the interrupt was a single-step interrupt (Trap Flag was set), the Trap Flag is cleared.
        
6. **Interrupt Vector Fetch:** The CPU uses the interrupt type to calculate the address of the corresponding interrupt vector in the Interrupt Vector Table (IVT). The IVT is a table in memory (starting at address 0000:0000) that holds the addresses of the Interrupt Service Routines (ISRs). Each interrupt type has a 4-byte entry in the IVT (2 bytes for the IP and 2 bytes for the CS of the ISR).
    
7. **Jump to ISR:** The CPU loads the CS and IP registers with the values fetched from the IVT. This effectively jumps execution to the beginning of the appropriate ISR.
    
8. **ISR Execution:** The ISR code is executed. This code handles the specific task associated with the interrupt.
    
9. **IRET Instruction:** The ISR concludes with an IRET (Interrupt Return) instruction.
    
10. **Restore Flags and Return Address:** The IRET instruction pops the saved CS, IP, and Flags registers from the stack, restoring the CPU to the state it was in before the interrupt occurred.
    
11. **Resume Interrupted Program:** The CPU continues executing the original program from the instruction following the one that was interrupted.